*** decrypt_keyctl.orig	2018-04-13 05:10:47.322786192 -0400
--- decrypt_keyctl	2018-04-13 04:56:08.593941949 -0400
***************
*** 13,18 ****
--- 13,38 ----
  #  test1 and test2 have the same identifier thus test2 does not need a password
  #  typed in manually
  
+ 
+ if [ -z $RECURSE_COUNTER ]; then
+     RECURSE_COUNTER=0
+ fi
+ 
+ RECURSE_COUNTER=$(( $RECURSE_COUNTER + 1 ))
+ 
+ if [ $RECURSE_COUNTER -eq 1 ]; then
+     export RECURSE_COUNTER
+     # Start a new program with a new session keyring. This guarantees that
+     # there _is_ a session keyring to use below.  There is an edge case
+     # where the session keyring has expired (typically after three days)
+     # and creating a new session keyring avoids that pitfall.  Here we're
+     # calling ourselves... the test on RECURSE_COUNTER makes sure the
+     # child process doesn't also recurse but instead executes the body
+     # of the script below.
+     keyctl session - $0 $1
+     exit $?
+ fi
+ 
  die()
  {
      echo "$@" >&2
***************
*** 73,80 ****
          keyctl unlink $KID_ @u
          KID_=""
      fi
!     KID_=$(echo -n "$KEY_" |keyctl padd user "$ID_" @u)
      [ -z "$KID_" ] && die "Error adding passphrase to kernel keyring"
      if ! keyctl timeout $KID_ $TIMEOUT_; then
          keyctl unlink $KID_ @u
          die "Error setting timeout on key ($KID_), removing"
--- 93,129 ----
          keyctl unlink $KID_ @u
          KID_=""
      fi
!     # Use the session keyring, not the user keyring, as we may not
!     # possess the user keying.  This happens when you su to root from
!     # an ssh session, and in that case we are the owner of the user
!     # keyring, but not the possessor of it.  This doesn't seem to happen
!     # when you su to root from the console.  I don't really understand
!     # why there is a difference, but there is.
!     KID_=$(echo -n "$KEY_" |keyctl padd user "$ID_" @s)
      [ -z "$KID_" ] && die "Error adding passphrase to kernel keyring"
+ 
+     # Set the permissions on the new key (we possess it since we possess
+     # the session (@s) keyring, so we can set the permissions).
+     if ! keyctl setperm $KID_ 0x3f3f0000; then
+ 	keyctl unlink $KID_ @s
+ 	die "Error setting permissions on key ($KID_), removing..."
+     fi
+ 
+     # Now link the new key to the user (@u, in this case root's) keyring
+     # so that it persists across invocations of this script.
+     if ! keyctl link $KID_ @u; then
+ 	keyctl unlink $KID_ @s
+ 	die "Error linking key ($KID_) to the @u keyring, removing..."
+     fi
+ 
+     # Finally unlink the key from the session keyring (@s) so the original
+     # possessor of the key (could be anyone if they su root) doesn't have
+     # access to the key. Not sure this is really necessary, but good
+     # practice.
+     if ! keyctl unlink $KID_ @s; then
+ 	echo "WARNING: unable to unlink key ($KID_) from the @s keyring." >&2
+     fi
+ 
      if ! keyctl timeout $KID_ $TIMEOUT_; then
          keyctl unlink $KID_ @u
          die "Error setting timeout on key ($KID_), removing"
